---
categories: ["hack"]
date: 2016-10-23T23:06:20+09:00
description: "explanation of Proof of Custody"
draft: true
keywords: ["blockchain"]
title: Proof of Custodyとは
---

## イントロ

Storjなどの分散ストレージシステムで、データ保持者にインセンティブを与えるための仕組みです。

データの送信それ自体は、送信されたデータの属性ではない(「写像関係は写像されない」という論理哲学論考の一説を思い出しますね。関係ないけど)ため、セキュアな経路を通して送られたデータを保持していることを暗号学的に証明する方法はない。

もう少し詳しく説明するため、いつもの二人（アリスとボブ）と第三者に手伝ってもらいます。

1. ボブは非対称鍵のペアを持っている。
2. アリスがボブにファイルの秘密分散を送る。
3. 第三者はファイルの送信が実際におこったということを確かめたい。

「ボブがファイルを持っている」という事実をアリスが証明するには、彼女はボブの秘密鍵を持たなくてはならない（ので無理）。
ボブが証明するには、ファイルそのものを承認機関と共有しなくてはならない。（ので無理）

もう少し硬い言い方をすると

`$ f(x,y) $`を計算するには、`$ x $`と`$ y $`に同時にアクセスしなくてはならない。（`$ x $`、`$ y $`はそれぞれ秘密鍵とデータ）

つまり

`$ f(x,y) = g(h(x), y) $`または`$ f(x,y) = g(x,h(y)) $`を満たすような一方向関数`$ h $`はいかなる`$ g $`に対しても存在しない。
といえます。

さてどうしましょう。PoCと呼ばれる一種の[ゼロ知識証明](https://ja.wikipedia.org/wiki/%E3%82%BC%E3%83%AD%E7%9F%A5%E8%AD%98%E8%A8%BC%E6%98%8E)プロトコルを用います。

### 定式化

* s ... 秘密鍵
* P ... 公開鍵
* D ... 証明したいデータ
* r(D) ... Dの指紋
* PoC(s, D) ... Proof of Custody
* V() ... Verification Function、つまり V(PoC(s, D), r(D), P) = l を満たす。(lは既知)


ここで、V()が承認を行えるということはつまり、sとDに同時にアクセスした時だけ、PoC(s, D)が計算できるということ

前提として、承認機関は、ボブのものであることが確かな公開鍵を持たなくてはならない。また、承認を行う前にDの指紋をゲットしておかなくてはならない。

以下の手順でPoCを行う。

1. ボブがファイルをDiに分割する
2. それぞれのDiについて証明を準備し、コミットメントを承認機関に送信する。
3. それぞれのDiについて、チャレンジをボブに返す。
4. ボブがPoCで応答する。
5. 承認する

### PoC

割と普通のゼロ知識証明。楕円曲線`$ E(F_q) $`とその上の点`$P \in E(F_q) $`を考える。

* `n` ... 皆で合意済みの暗号の次数。強度を決める。
* `$ F_q $` ... 次数qの有限体。
* `ボブの公開鍵は、楕円曲線上の`$ Q \in E(F_q) $`で次数はn、秘密鍵sは$`Q = sP $`を満たす整数、ただし`$ l < s < n $`

1. コミットメント ... ボブは秘密のランダムな数`$ k \in {1,...,n} $`を選び`$ R=kP $`を承認機関に送信する。
2. チャレンジ ... サーバーは2つの値からランダムに一つ選び（`$ e \in {0,1} $`）ボブに送る。
3. 応答 ... `$ a = (k + se) mod n $`を計算し、aをサーバーに送る。
4. 承認 ... `$ aP = R + eQ $`を満たせば承認する。

kはより大事な秘密sを「隠す」のに使用されている。eが`[0, n]`と一緒ならばSchnorr Identification Protocolと一致

適当に答えても2/1の確率で正解するため、何回も行う（= ファイルの分割と、認証の強度が比例する。）

