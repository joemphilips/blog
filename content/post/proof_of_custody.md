---
categories: ["hack"]
date: 2016-10-24T23:21:13+09:00
description: "explanation of Proof of Custody"
draft: false
keywords: ["blockchain"]
title: ゼロ知識証明によるProof of Custodyの仕組み
---

# 前提

Storjなどの分散ストレージシステムでは、データ保持者にインセンティブを与えるため「保持していること」を証明する方法が必要

データの送信それ自体は、送信されたデータの属性ではない[^1]ため、セキュアな経路を通して送られたデータを保持していることを暗号学的に証明する方法はない。

もう少し詳しく説明するため、いつもの二人（アリスとボブ）と第三者に手伝ってもらう。

1. ボブは非対称鍵のペアを持っている。
2. アリスがボブにファイルの秘密分散を送る。
3. 第三者はファイルの送信が実際におこったということを確かめたい。

「ボブがファイルを持っている」という事実をアリスが証明するには、彼女はボブの秘密鍵を持たなくてはならない（ので無理）。
ボブが証明するには、ファイルそのものを承認機関と共有しなくてはならない。（ので無理）

もう少し硬い言い方をすると

`$ f(x,y) $`を計算するには、`$ x $`と`$ y $`に同時にアクセスしなくてはならない。（`$ x $`、`$ y $`はそれぞれ秘密鍵とデータ）

つまり

`$ f(x,y) = g(h(x), y) $`または`$ f(x,y) = g(x,h(y)) $`を満たすような一方向関数`$ h $`はいかなる`$ g $`に対しても存在しない。
といえる。

そこで、一種の[ゼロ知識証明](https://ja.wikipedia.org/wiki/%E3%82%BC%E3%83%AD%E7%9F%A5%E8%AD%98%E8%A8%BC%E6%98%8E)プロトコルを用いる。

## 定式化

厳密な議論のために、記号を導入する。

* s ... 秘密鍵
* P ... 公開鍵
* D ... 証明したいデータ
* r(D) ... Dの指紋
* PoC(s, D) ... Proof of Custody
* V() ... Verification Function、つまり V(PoC(s, D), r(D), P) = l を満たす。(lは既知)


ここで、V()が承認を行えるということはつまり、sとDに同時にアクセスした時だけ、PoC(s, D)が計算できるということ

前提として、承認機関は、ボブのものであることが確かな公開鍵を持たなくてはならない。また、承認を行う前にDの指紋をゲットしておかなくてはならない。

以下の手順でPoCを行う。

1. ボブがファイルをDiに分割する
2. それぞれのDiについて証明を準備し、コミットメントを承認機関に送信する。
3. それぞれのDiについて、チャレンジをボブに返す。
4. ボブがPoCで応答する。
5. 承認する

# PoC

ここからはゼロ知識証明によるPoCのプロトコルについて説明を行う。

## ゼロ知識証明による秘密鍵の存在証明

まず前提として、普通のゼロ知識証明を用いて、秘密鍵の存在を証明する場合を説明する。楕円曲線`$ E(F_q) $`とその上の点`$P \in E(F_q) $`を考える。

* `$ n $` ... 皆で合意済みの暗号の次数。強度を決める。
* `$ F_q $` ... 次数qの有限体。
* ボブの公開鍵は、楕円曲線上の`$ Q \in E(F_q) $`で次数はn、秘密鍵sは`$Q = sP$`を満たす整数、ただし`$ l < s < n $`

という条件の場合、秘密鍵のゼロ知識証明は以下の4ステップから成る。

1. コミットメント ... ボブは秘密のランダムな数`$ k \in {1,...,n} $`を選び`$ R=kP $`を承認機関に送信する。
2. チャレンジ ... サーバーは2つの値からランダムに一つ選び（`$ e \in {0,1} $`）ボブに送る。
3. 応答 ... `$ a = (k + se) mod n $`を計算し、aをサーバーに送る。
4. 承認 ... `$ aP = R + eQ $`を満たせば承認する。

kはより大事な秘密sを「隠す」のに使用されている。eが`$ e \in [0,n] $`ならばSchnorr Identification Protocolと一致

適当に答えても2/1の確率で正解するため、何回も行う（= ファイルの分割と、認証の強度が比例する。）

## ファイルの存在証明

サーバーがファイルのどの断片を証明に用いるかをランダムに決めることを除けば、上に似ている。

1. コミットメント ... それぞれのファイルの断片iについて、ランダムな値`$ k_i $`を選ぶ。上と同じように`$ R_i = k_iP $`を送るのに加えて、ハッシュ関数Hを用いて、ハッシュ値`$ H_i = H(k_i + D_i) $`も送る。
2. セレクション ... `$ i \in [l,t] $`
3. チャレンジ ... サーバーが適当に`$ e \in {0,1} $`を決めボブに送る。
4. 応答 ... `$ a_i = k_i + se_i (mod n) $`を計算し、を計算し、サーバーに送る。`$ e = 0 $`ならば、`$ D_i $`が`$ D $`の一部であることの証明(merkle proof[^2])もサーバーに送る
5. 以下を満たす場合サーバーは証明を受理する。
 - `$ e_i = 0 $` の場合 ... `$ a_iP = R_i $`, `$ H(a_i + D_i) = H_i $`が成立し、かつ`$ D_i $`がDの一部であるという証明が成り立つ。
 - `$ e_i = 1 $` ... `$ a_iP = R_i + Q $`が成り立つ。
6. 2から5を十分回繰り返す。

[^1]: 「写像関係は写像されない」という論理哲学論考の一説を思い出しますね。関係ないけど
[^2]: merkel木のrootノードのハッシュ値を再現できるようなハッシュ値の組、詳しくは[wikipedia](https://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E6%9C%A8)を参照
